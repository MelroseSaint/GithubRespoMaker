const express = require('express');
const path = require('path');
const cors = require('cors');
const fs = require('fs');
const multer = require('multer');
const AdmZip = require('adm-zip');
const archiver = require('archiver');

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

function log(msg) {
  const line = `[${new Date().toISOString()}] ${msg}\n`;
  try { fs.appendFileSync(path.join(__dirname, 'server.log'), line); } catch (_) {}
  console.log(line.trim());
}

// Simple request logger to debug routing
app.use((req, res, next) => {
  log(`${req.method} ${req.path}`);
  next();
});

// Health & ping FIRST
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});
app.get('/ping', (req, res) => res.send('pong'));

// Docs route using regex to capture any subpath
const docsRoot = path.join(__dirname, 'docs');
app.get(/^\/docs\/(.+)/, (req, res) => {
  const rel = req.params[0];
  const resolvedPath = path.resolve(docsRoot, rel);
  if (!resolvedPath.startsWith(docsRoot)) {
    return res.status(400).send('Invalid path');
  }
  res.sendFile(resolvedPath, err => {
    if (err) res.status(err.status || 404).send('Not Found');
  });
});

// Static assets
app.use(express.static(path.join(__dirname, 'public')));
app.use('/docs', express.static(docsRoot));

// Generator endpoints
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024, files: 100 } });

function normalizeAdvancedConfig(rawStr) {
  let obj = {};
  try { obj = JSON.parse(rawStr || '{}'); } catch (_) {}
  return {
    gitHooks: !!(obj.gitHooks ?? obj.includeGitHooks),
    cicd: !!(obj.cicd ?? obj.includeCICD),
    docker: !!(obj.docker ?? obj.includeDocker),
    testing: !!(obj.testing ?? obj.includeTesting),
    linting: !!(obj.linting ?? obj.includeLinting),
    vscode: !!(obj.vscode ?? obj.includeVSCode),
  };
}

function addBaseFiles(archive, { repoName, description }) {
  const readme = `# ${repoName}\n\n${description ? description + '\n\n' : ''}Generated by RespoGen.\n`;
  archive.append(readme, { name: 'README.md' });
  archive.append('node_modules/\noutput/\n.env\n.DS_Store\n', { name: '.gitignore' });
  archive.append('root = true\n\n[*]\nindent_style = space\nindent_size = 2\n', { name: '.editorconfig' });
  archive.append('NODE_ENV=development\nPORT=3000\n', { name: '.env.example' });
  archive.append('MIT License\n', { name: 'LICENSE' });
}

function addTemplateSkeleton(archive, template) {
  switch (template) {
    case 'react-app':
      archive.append('import React from "react";\nexport default function App(){return <h1>Hello React</h1>;}', { name: 'src/App.jsx' });
      archive.append('import React from "react";\nimport { createRoot } from "react-dom/client";\nimport App from "./App.jsx";\ncreateRoot(document.getElementById("root")).render(<App/>);', { name: 'src/main.jsx' });
      archive.append('<!doctype html><html><body><div id="root"></div><script src="/src/main.jsx"></script></body></html>', { name: 'public/index.html' });
      break;
    case 'node-api':
      archive.append('const express=require("express");const app=express();app.get("/",(req,res)=>res.json({ok:true}));app.listen(3000);', { name: 'server/index.js' });
      break;
    case 'python-flask':
      archive.append('from flask import Flask\napp = Flask(__name__)\n@app.route("/")\ndef hello():\n    return {"ok": True}\n', { name: 'app.py' });
      break;
    case 'docker-node':
      archive.append('FROM node:18\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD ["npm","start"]\n', { name: 'Dockerfile' });
      archive.append('version: "3"\nservices:\n  app:\n    build: .\n    ports:\n      - "3000:3000"\n', { name: 'docker-compose.yml' });
      break;
    case 'static-site':
      archive.append('<!doctype html><html><head><meta charset="utf-8"><title>Static</title></head><body><h1>Hello</h1></body></html>', { name: 'index.html' });
      break;
    case 'nextjs-app':
      archive.append('import React from "react";export default function Page(){return <h1>Hello Next</h1>};', { name: 'pages/index.jsx' });
      break;
    case 'monorepo':
      archive.append('Monorepo placeholder', { name: 'packages/README.txt' });
      break;
    default:
      archive.append('src placeholder', { name: 'src/README.txt' });
  }
}

function addAdvancedConfigFiles(archive, adv) {
  if (adv.cicd) {
    const ci = 'name: CI\n\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 18\n      - run: npm ci\n      - run: npm test || echo "no tests"';
    archive.append(ci, { name: '.github/workflows/ci.yml' });
  }
  if (adv.gitHooks) {
    archive.append('# Husky hooks placeholder', { name: '.husky/README.md' });
  }
  if (adv.docker) {
    archive.append('FROM node:18\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD ["npm","start"]\n', { name: 'Dockerfile' });
    archive.append('version: "3"\nservices:\n  app:\n    build: .\n    ports:\n      - "3000:3000"\n', { name: 'docker-compose.yml' });
  }
  if (adv.testing) {
    archive.append('{"name":"tests"}', { name: 'tests/package.json' });
  }
  if (adv.linting) {
    archive.append('{"extends": ["eslint:recommended"] }', { name: '.eslintrc.json' });
    archive.append('{ }', { name: '.prettierrc' });
  }
  if (adv.vscode) {
    archive.append('{"editor.tabSize":2}', { name: '.vscode/settings.json' });
  }
}

function addSnippets(archive, snippetsJson) {
  let items = [];
  try { items = JSON.parse(snippetsJson || '[]'); } catch (_) {}
  if (Array.isArray(items)) {
    items.forEach(({ filename, content }) => {
      if (filename && typeof content === 'string') archive.append(content, { name: `snippets/${filename}` });
    });
  }
}

function addUploadedFiles(archive, files) {
  if (!Array.isArray(files)) return;
  const zipFile = files.find(f => f.fieldname === 'zip');
  if (zipFile) {
    try {
      const z = new AdmZip(zipFile.buffer);
      z.getEntries().forEach(e => {
        if (!e.isDirectory) archive.append(e.getData(), { name: `uploaded/${e.entryName}` });
      });
    } catch (_) {}
  }
  files.filter(f => f.fieldname === 'files').forEach(f => {
    archive.append(f.buffer, { name: `uploaded/${f.originalname}` });
  });
}

app.post('/generate', upload.any(), async (req, res) => {
  const repoName = (req.body.repoName || 'my-project').toString().trim();
  const description = (req.body.description || '').toString();
  const template = (req.body.template || 'static-site').toString();
  const adv = normalizeAdvancedConfig(req.body.advancedConfig);

  res.setHeader('Content-Type', 'application/zip');
  res.setHeader('Content-Disposition', `attachment; filename="${repoName}.zip"`);

  const archive = archiver('zip', { zlib: { level: 9 } });
  archive.on('error', (err) => { try { res.status(500).send(err.message); } catch (_) {} });
  archive.pipe(res);

  addBaseFiles(archive, { repoName, description });
  addTemplateSkeleton(archive, template);
  addAdvancedConfigFiles(archive, adv);
  addSnippets(archive, req.body.snippets);
  addUploadedFiles(archive, req.files);

  await archive.finalize();
});

app.post('/api/generate', upload.none(), (req, res) => {
  const repoName = (req.body.repoName || 'my-project').toString().trim();
  res.json({ status: 'ok', repo: repoName });
});

// 404 fallback
app.use((req, res) => {
  res.status(404).send('Not Found');
});

app.listen(PORT, () => {
  log(`RespoGen server running at http://localhost:${PORT}`);
});